# Gemini Research

Implementing a Modern Constraint-Based Sketching System: Architecture and Algorithms for OneCAD1. Introduction: The Strategic Imperative of Robust Parametric SketchingIn the contemporary landscape of Computer-Aided Design (CAD), the sketching environment serves as the foundational interface between human intent and geometric realization. It is the primary vector through which vague concepts are transmuted into mathematically rigorous definitions. For the proposed custom application, "OneCAD," the objective is not merely to replicate existing functionality found in legacy systems but to synthesize a modern, high-performance architecture that bridges the gap between the precision of traditional parametric modelers (like SolidWorks or Catia) and the fluid, intuitive user experience (UX) pioneered by next-generation tools like Shapr3D.This report provides an exhaustive, implementation-ready architectural guide for constructing this system. The technology stack selected—C++ for the core logic, Qt 6 for the user interface and event handling, OpenCASCADE Technology (OCCT) for the topological kernel, and PlaneGCS for geometric constraint solving—represents a potent combination of industrial-grade reliability and modern performance capabilities. However, the integration of these disparate components requires a nuanced understanding of computational geometry, numerical optimization, and software architecture.The report is structured to guide the engineering team through every critical phase of development. It begins by dissecting the mathematical theories underpinning geometric constraint solving, moving beyond simple algebraic definitions to explore the numerical optimization strategies necessary for stability. It then provides a blueprint for the surgical extraction and integration of the PlaneGCS solver from its FreeCAD origins. Subsequent sections address the user experience, detailing the implementation of "Noun-Verb" interaction patterns and visual debugging systems that reduce cognitive load. The report also tackles the two most notoriously difficult problems in CAD development: the robust detection of closed profiles (loops) from raw sketch strokes, and the Topological Naming Problem (TNP), which threatens model stability during parametric updates. Finally, it outlines policies for Hybrid Modeling, ensuring that OneCAD can gracefully handle both history-based and direct modeling paradigms.2. Theoretical Foundations of Geometric Constraint SolvingTo implement a robust solver, one must first understand that a Geometric Constraint System (GCS) is fundamentally a root-finding problem for a system of non-linear algebraic equations. While the user perceives constraints as logical rules (e.g., "Line A is parallel to Line B"), the solver perceives them as mathematical functions that must be minimized.2.1 The Mathematical Model of ConstraintsA 2D sketch consists of a set of geometric entities $E = \{e_1, e_2,..., e_n\}$ and a set of constraints $C = \{c_1, c_2,..., c_m\}$. Each entity contributes a specific number of Degrees of Freedom (DOF) to the system state vector $X$. The state vector $X$ is a concatenation of all generalized coordinates defining the sketch geometry.The total degrees of freedom ($DOF_{total}$) of a system containing $n_p$ points, $n_l$ lines, $n_c$ circles, and $n_e$ ellipses is given by:$$DOF_{total} = 2n_p + 2n_l + 3n_c + 5n_e$$Each constraint removes degrees of freedom by imposing algebraic equations. A constraint $c_k$ defines a scalar function $f_k(X)$ such that the constraint is satisfied when $f_k(X) = 0$.2.1.1 Algebraic Representation of Common ConstraintsUnderstanding the exact algebraic formulation is crucial for debugging solver convergence issues.Constraint TypeGeometric Entities InvolvedDegrees of Freedom RemovedAlgebraic Equation formulation (f(X)=0)CoincidentPoint $P_1$, Point $P_2$2$x_1 - x_2 = 0$, $y_1 - y_2 = 0$Point-on-LinePoint $P(x,y)$, Line $L(p, \theta)$1$x \sin\theta - y \cos\theta - p = 0$DistancePoint $P_1$, Point $P_2$, Length $L$1$(x_2 - x_1)^2 + (y_2 - y_1)^2 - L^2 = 0$ParallelLine $L_1(\theta_1)$, Line $L_2(\theta_2)$1$\sin(\theta_1 - \theta_2) = 0$PerpendicularLine $L_1(\theta_1)$, Line $L_2(\theta_2)$1$\cos(\theta_1 - \theta_2) = 0$TangencyLine $L$, Circle $C(x_c, y_c, r)$1Distance(Line, Center) $- r = 0$The aggregate system is represented as a vector function $F(X) = [f_1(X), f_2(X),..., f_m(X)]^T = 0$. The Jacobian matrix $J(X)$, containing partial derivatives $\partial f_i / \partial x_j$, describes how constraint errors change with respect to geometry changes.12.2 Decomposition and Graph-Based ReductionSolving the global system $F(X)=0$ simultaneously for all entities is computationally prohibitive ($O(N^3)$) and numerically unstable for large sketches. Modern solvers, including PlaneGCS, employ decomposition strategies to break the problem into smaller, manageable subsystems.42.2.1 Graph Analysis and ConnectivityBefore any numerical processing, the system is modeled as a constraint graph where nodes represent geometric entities and edges represent constraints. The solver analyzes this graph to identify Connected Components and Rigid Clusters.1Connected Components: If a sketch contains two disjoint shapes (e.g., a rectangle on the left and a circle on the right) with no constraints linking them, the Jacobian matrix is block-diagonal. The solver must detect this and solve each component independently. This is essential for performance; dragging the rectangle should not trigger a re-solve of the circle. PlaneGCS handles this via the GCS::System class, which manages multiple SubSystem instances.6Rigid Clusters: The solver searches for subgraphs that are internally well-constrained (DOF = 0). For example, three lines connected by endpoints with fixed lengths form a rigid triangle. This triangle can be treated as a single rigid body with only 3 DOF (translation $x, y$, rotation $\theta$) in the larger system, significantly reducing the dimensionality of the numerical problem.12.3 Numerical Optimization MethodsOnce decomposed, the remaining coupled non-linear equations must be solved. While the Newton-Raphson method is the textbook approach for finding roots, it is often unsuitable for interactive CAD because it requires a square system (number of equations = number of variables) and diverges easily if the initial guess is poor.32.3.1 Least Squares MinimizationPlaneGCS and robust industrial solvers reformulate the root-finding problem as an optimization problem:$$\min_{X} \Phi(X) = \frac{1}{2} \| F(X) \|^2 = \frac{1}{2} \sum_{i=1}^m f_i(X)^2$$This formulation allows the solver to handle:Over-constrained systems: Finds the "best fit" solution where error is minimized, rather than failing.Under-constrained systems: Finds a solution close to the initial state (preserving the user's rough sketch).32.3.2 The Levenberg-Marquardt AlgorithmThe preferred algorithm for this minimization is Levenberg-Marquardt (LM). LM adaptively interpolates between two methods based on the proximity to the solution:Gradient Descent: Used when far from the solution. It is slow but robust, guaranteed to decrease the error.Gauss-Newton: Used when close to the solution. It assumes the function is locally quadratic and converges rapidly.9The update step $\delta$ is calculated by solving:$$(J^T J + \lambda I)\delta = -J^T F(X)$$where $\lambda$ is a damping parameter. If the error decreases, $\lambda$ is reduced (approaching Gauss-Newton); if the error increases, $\lambda$ is increased (approaching Gradient Descent). This "trust region" approach makes LM significantly more stable than pure Newton-Raphson for sketching, where users often drag geometry into degenerate configurations (e.g., collapsing a triangle to a line).42.3.3 The Dogleg MethodPlaneGCS specifically implements the Dogleg method (Powell's Dogleg), a sophisticated variant of the trust-region approach.4 The Dogleg method constructs a path consisting of two line segments in the design space: one from the current point to the Cauchy point (steepest descent direction) and another from the Cauchy point to the Newton point. This allows for a more efficient traversal of the solution space than standard LM in many geometric scenarios.3. PlaneGCS and FreeCAD Architecture IntegrationIntegrating PlaneGCS into OneCAD requires surgical extraction. PlaneGCS is deeply embedded in FreeCAD's Sketcher module, relying on FreeCAD's Base system for persistence and linear algebra. The following section details the architectural adaptation required.3.1 Source Code Analysis and ExtractionThe relevant source code is located in src/Mod/Sketcher/App/planegcs/ of the FreeCAD repository.6 The core files required for a standalone library are:GCS.cpp / GCS.h: The main solver interface.SubSystem.cpp / SubSystem.h: Manages connected components.Constraints.cpp: Definitions of constraint equations.VEC_pI.cpp: Internal vector implementations.3.1.1 Dependency Stripping StrategyTo make PlaneGCS independent of FreeCAD:Remove Base::Persistence: PlaneGCS classes often inherit from Base::Persistence or App::DocumentObject for file serialization.13 OneCAD uses its own serialization (likely JSON or binary format via Qt). The inheritance must be removed, and the Save()/Restore() methods refactored to serializing simple structs.Replace Vector Math: PlaneGCS uses Base::Vector3d. This should be replaced with a lightweight adapter class that maps to Eigen vectors (used internally by the solver) or OpenCASCADE’s gp_Pnt. Given that the solver relies heavily on Eigen for matrix operations (QR decomposition, etc.) 4, standardizing on Eigen for the solver internals is recommended.Boost Removal: While FreeCAD uses Boost extensively, snippets suggest that for PlaneGCS, its usage is primarily for graph algorithms (connected components).5 If OneCAD aims to minimize dependencies, these graph traversals can be rewritten using standard C++17 STL algorithms (BFS/DFS), or the specific Boost headers can be kept as a private dependency.3.2 The Wrapper ArchitectureA direct "Solver-in-the-Loop" architecture is required to bridge OneCAD's Qt/C++ objects with PlaneGCS's numerical primitives.Class Structure Proposal:C++// OneCAD Sketch Solver Wrapper (Conceptual)

#include "GCS.h" // PlaneGCS header

class SketchSolver {
private:
    GCS::System gcsSystem;
    std::map<int, GCS::PointId> pointMap;
    std::map<int, GCS::ConstraintId> constraintMap;
    int nextId = 0;

public:
    // Initialization
    void clear() { gcsSystem.clear(); pointMap.clear(); }

    // Geometry Injection
    void addPoint(int oneCadId, double x, double y) {
        GCS::PointId pid = gcsSystem.addPoint(x, y);
        pointMap[oneCadId] = pid;
    }

    void addLine(int oneCadId, int p1Id, int p2Id) {
        // PlaneGCS treats lines as connections between points
        // Constraints enforce the topology
    }

    // Constraint Injection
    void addDistanceConstraint(int id, int p1Id, int p2Id, double dist) {
        GCS::ConstraintId cid = gcsSystem.addConstraintDistance(
            pointMap[p1Id], 
            pointMap[p2Id], 
            dist
        );
        constraintMap[id] = cid;
    }

    // The Solve Loop
    bool solve() {
        // 1. Diagnosis: Decompose into subsystems
        // 2. Optimization: Run Dogleg/LM
        int result = gcsSystem.solve(); 
        
        if (result == GCS::Success) {
            syncCoordinatesBackToOneCAD();
            return true;
        } else {
            analyzeConflict(); // See Section 5.3
            return false;
        }
    }
    
    // Feedback
    void syncCoordinatesBackToOneCAD() {
        for (auto const& [oneCadId, gcsPid] : pointMap) {
             double x, y;
             gcsSystem.getPoint(gcsPid, x, y);
             OneCAD::updatePoint(oneCadId, x, y);
        }
    }
};
This wrapper encapsulates the complexity of ID mapping. PlaneGCS uses its own internal integer IDs; OneCAD must maintain a robust map between its persistent UUIDs (see Section 6) and these transient solver IDs.3.3 Managing Performance and DraggingFor an interactive experience (60 FPS dragging), calling gcsSystem.solve() on the entire sketch during every mouse move event is inefficient for sketches with >1000 entities.Incremental Update Strategy:Subsystem Solving: The GCS::System automatically maintains subsystems.7 When a user drags a point, the wrapper should query which subsystem that point belongs to and trigger a solve only for that subsystem.Warm Start: Do not reset the solver state between drag frames. The solution from frame $t$ is the ideal initial guess for frame $t+1$. This exploits the quadratic convergence of the Gauss-Newton component of the LM algorithm.9Qt Event Loop:Mouse Move: Update the coordinates of the "dragged" parameter in the GCS system.Solve Trigger: Call solve().Repaint: If successful, trigger update() on the QGraphicsScene.Note: For extremely complex solves (>10ms), this loop must move to a background thread (QThread or std::async), utilizing a double-buffer strategy for the coordinate data to prevent UI freezing.164. Shapr3D-like UX Patterns and Interaction DesignModern users demand a "transparent" interface. The distinction between "drawing" and "constraining" should blur. The goal is to implement the Noun-Verb selection paradigm and Feed-Forward visual debugging.4.1 Noun-Verb Interaction ParadigmIn traditional CAD (Verb-Noun), the user selects a tool (e.g., "Perpendicular") and then identifies the operands (Line A, Line B). In the Noun-Verb paradigm (Shapr3D, NX), the user selects objects first, and the system presents valid actions.17Implementation in Qt:Selection Manager: A central class tracks the std::set<Entity*> of selected items.Context Engine: Upon selection change, the engine analyzes the set:Selection: {Line, Line} -> Context Menu: [Parallel, Perpendicular, Equal, Collinear]Selection: {Line, Circle} -> Context Menu: ``Selection: {Point, Point} -> Context Menu: ``UI Component: A QGraphicsWidget or QML component floating near the cursor (or at the bottom right) updates dynamically. This reduces mouse travel and cognitive load, as users don't need to hunt through toolbars.4.2 Auto-Constraining (The "Magnetic" Cursor)Shapr3D’s "magic" lies in its aggressive auto-constraining.17 As the user draws, the system infers intent.Algorithmic Logic:While the mouse is moving (e.g., drawing a line endpoint):Search Radius: Query a spatial index (QuadTree) for entities within $N$ pixels of the cursor.Geometric Checks:Coincidence: Is distance to vertex < Tolerance?Horizontal/Vertical: Is $|\Delta x| < \epsilon$ or $|\Delta y| < \epsilon$?Tangency: If drawing from an arc endpoint, is the vector difference between the mouse vector and the arc tangent vector $\approx 0$?Perpendicular/Parallel: Check alignment with other visible lines in the viewport.Visualization (Feed-Forward): Before the user clicks, draw a phantom constraint icon (e.g., a tiny perpendicular symbol) and "snap" the rendering of the line to the constrained position.Commit: If the user clicks while the phantom icon is visible, the system creates both the geometry and the constraint simultaneously.Constraint Settings:Users must have control over this behavior. A settings panel should allow toggling individual auto-constraints (e.g., disable "Auto-Parallel" but keep "Auto-Coincident") to prevent unwanted inferences in complex areas.174.3 Visual Debugging: The Traffic Light SystemA sketch is a logic puzzle. When the puzzle is broken, the user needs immediate, colorful feedback, not cryptic error codes. OneCAD should adopt a rigorous state visualization policy.20Color StateMeaningSolver StateUI ActionBlueUnder-defined$DOF > 0$Allow dragging. Show remaining DOFs (e.g., endpoints can move).BlackFully Defined$DOF = 0$Fixed in space. No dragging allowed unless constraints removed.YellowWarningSolved, but nearing singularity or dangling ref.Highlight specific entity. Tooltip: "Reference lost".RedOver-definedResidual $\Phi(X) > \text{Tolerance}$Solve failed. Highlight conflicting constraints.4.3.1 Visualizing ConflictsWhen PlaneGCS fails (returns non-zero residual), OneCAD must identify the "conflict set".22Minimal Conflict Set (MCS): The solver does not natively output "Constraint A conflicts with Constraint B." OneCAD must implement a diagnostic wrapper that iteratively relaxes constraints to see which removal allows the system to converge.UI Feedback: Highlight the MCS in Red. Display a "Sketch Doctor" or "Repair" dialog that offers buttons: "Delete Constraint A" or "Delete Constraint B" to resolve the conflict.245. Computational Geometry: From Strokes to RegionsA sketch is fundamentally a collection of 1D curves. However, 3D operations (Extrude, Revolve) require 2D Regions (Faces). Converting a "soup" of intersecting lines into clean topological faces is a non-trivial graph theory problem.5.1 The Planar Straight Line Graph (PSLG) PipelineThe robust conversion from strokes to regions follows a six-step pipeline, often referred to as "Planarization".26Step 1: Prepare (Intersection & Splitting)The raw input may contain lines that cross each other without a vertex at the crossing.Algorithm: Bentley-Ottmann sweep-line algorithm.26Action: Find all intersection points. Split edges at these points. Insert new vertices.Result: A set of edges that intersect only at their endpoints.Step 2: Subdivide (Handling Curves)Planar graph algorithms work best on lines.Action: Temporarily tessellate circles, arcs, and splines into polyline approximations. Maintain a mapping PolyLineSegment -> OriginalCurveID for the restoration phase.26Step 3: Graph Construction (Half-Edge Data Structure)Build a Directed Graph where each undirected edge becomes two directed "Half-Edges" (twins).Crucial Step: For every vertex, sort the outgoing half-edges radially (by angle). This angular ordering is the key to traversing faces.28Step 4: Extract (Face Traversal)Traverse the graph to find cycles.Algorithm: Left-Most Turn Rule (or Next Counter-Clockwise).Start at an unvisited half-edge.Traverse to the target vertex.Select the outgoing edge that is the immediate counter-clockwise neighbor of the incoming edge (using the sorted list from Step 3).Repeat until the start vertex is reached.Optimization: Use the Jiang and Bunke algorithm for optimal $O(m \log m)$ region extraction, which uses a "wedge" based approach to manage traversals.26Step 5: Treeify (Hierarchy & Winding)Classify the cycles found in Step 4.Shoelace Formula: Calculate the signed area of each cycle.29Counter-Clockwise (Positive Area): A solid region (Island).Clockwise (Negative Area): A hole or the outer boundary.Nesting Detection: Use a Point-in-Polygon (Ray Casting) test to determine containment. Build a tree: Outer Boundary -> Face -> Hole -> Island.Note: Discard the "Infinite Face" (the region encompassing the outside of the sketch).Step 6: RestoreReplace the polyline segments in the detected cycles with the original TopoDS_Edge curves (Arcs, Splines) to create the final TopoDS_Wire and TopoDS_Face objects for OpenCASCADE.266. Topological Stability and The Naming Problem (TNP)The Topological Naming Problem is the most critical stability challenge in parametric CAD. It occurs when a 3D feature (e.g., a Fillet) references a sketch element (e.g., "Edge 5") by index. If the sketch is modified (e.g., a line is split), "Edge 5" might disappear or become a different edge, causing the Fillet to fail or attach to the wrong geometry.306.1 Leveraging OpenCASCADE OCAFOneCAD should utilize the OpenCASCADE Application Framework (OCAF), specifically the TNaming package, which is engineered to solve the TNP.316.1.1 The TNaming_NamedShape AttributeIn OCAF, geometry is not just a TopoDS_Shape. It is wrapped in a TNaming_NamedShape attribute attached to a label in the data hierarchy. This attribute stores the Evolution of the shape.33Evolution Types 32:PRIMITIVE: Initial creation (e.g., a new line in a sketch).GENERATED: A new shape created from an old one (e.g., an Extrude Face generated from a Sketch Edge).MODIFIED: A shape that has changed geometrically but represents the same topological entity (e.g., a line moved by the solver).DELETE: A shape removed from the model.6.2 Implementation Strategy: Stable IDsTo ensure stability, OneCAD must implement a persistent naming schema that survives solver re-evaluations.Sketch-Level UUIDs:Every SketchObject (Line, Circle) must be assigned a persistent UUID at creation. This UUID must be saved in the OneCAD file format. Do not rely on the integer IDs used by PlaneGCS, as these are transient.The TNaming_Builder:When the solver updates the sketch, the OneCAD wrapper must explicitly update the OCAF history using TNaming_Builder.32Scenario: Solver moves a line.C++TNaming_Builder builder(label);
builder.Modify(oldTopoDSEdge, newTopoDSEdge);
Scenario: User splits a line.C++TNaming_Builder builder(label);
builder.Generated(oldTopoDSEdge, newSegment1);
builder.Generated(oldTopoDSEdge, newSegment2);
This creates a topological history graph. When a downstream Fillet asks for "The edge derived from Sketch Line A," OCAF traverses this graph to find the current valid geometry (newSegment1 and newSegment2), allowing the fillet to potentially apply to both (or prompt the user), rather than failing.Edge Projection (External Geometry):When projecting a 3D edge into the sketch (e.g., "Use Edge" command), store a reference to the OCAF Label of the 3D edge, not the transient TopoDS_Edge pointer. On every sketch recompute, query the OCAF Label for its current shape. If the return is empty (Deleted), mark the projected sketch edge as "Broken" (Brown color) in the UI, alerting the user to fix the dangling reference.207. Hybrid Direct/Parametric Modeling PoliciesOneCAD aims to support both Parametric (history-based) and Direct (push-pull) modeling. These paradigms typically conflict: Parametric relies on strict history replay, while Direct modeling modifies B-Rep geometry arbitrarily, breaking the history chain.7.1 Policy: Bi-Directional SynchronizationThe most advanced policy, observed in high-end systems (NX, Fusion 360), attempts to map Direct Modeling operations back to Parametric parameters where possible.187.1.1 The "Push-Pull" AlgorithmWhen a user selects a face and drags it (Direct Modeling):Identification: The system traces the face back to its generating feature (e.g., Extrude_1) and the driving sketch (Sketch_1).Parameter Mapping:Calculate the drag vector $\Delta \vec{v}$.Case A (Extrude Depth): If $\Delta \vec{v}$ is parallel to the extrusion direction, map the drag distance to the Extrude_1.Depth parameter.Case B (Sketch Dimension): If $\Delta \vec{v}$ aligns with a dimensioned edge in Sketch_1, map the drag to that sketch constraint's value.Validation:Tentatively update the parameter.Trigger the PlaneGCS solver in the background.Success: If the solver converges without conflict, update the history and the 3D model. The Direct Modeling action is effectively converted into a Parametric edit.Failure: If the solver fails (e.g., the drag violates a constraint), the system falls back to Policy A (Override): it appends a "Direct Edit" feature (e.g., OffsetFace) to the end of the history tree, preserving the original sketch but overlaying the modification.187.2 Architecture for Hybrid UpdatesTo support this, the OneCAD data model must support Back-Pointers:TopoDS_Face $\rightarrow$ OCAF Label $\rightarrow$ Feature Object $\rightarrow$ Sketch Object.This lineage allows the "Pull" tool to query the solver constraints of the underlying sketch before modifying geometry.8. ConclusionThe architecture proposed for OneCAD represents a synthesis of rigorous mathematical principles and modern user-centric design. By extracting PlaneGCS, the application gains a proven, industrial-strength solver capable of handling complex constraint networks via the Levenberg-Marquardt and Dogleg algorithms. The integration of Qt 6 facilitates a responsive, "Shapr3D-like" interface characterized by Noun-Verb interactions and Auto-Constraining, which significantly lowers the barrier to entry for users.Crucially, the system addresses the structural weaknesses of typical custom CAD tools. The implementation of a Planar Straight Line Graph (PSLG) pipeline ensures robust region detection from raw strokes, enabling reliable 3D feature creation. Furthermore, the adoption of OpenCASCADE’s OCAF and TNaming mechanisms provides a defense against the Topological Naming Problem, ensuring that parametric models remain stable through revisions. Finally, the Hybrid Modeling policy bridges the gap between precision and flexibility, allowing OneCAD to function as both a rigorous engineering tool and a fluid conceptualizer. This holistic approach ensures OneCAD will not only function but compete effectively in the modern CAD marketplace.



---

# ChatGPT research

OneCAD Sketching & Constraints System Design
Data Model and Sketch Workflow

OneCAD follows a sketch-first workflow inspired by Shapr3D, where 2D sketches form the basis of 3D features. Users begin by selecting or creating a sketch plane (standard XY/XZ/YZ planes or an existing planar face) and entering Sketch Mode. In Sketch Mode, all drawn geometry is construction geometry by default (represented as dashed lines). The system continuously monitors the sketch for any closed loops. As geometry is drawn, OneCAD’s Loop Detection Engine runs in real-time to find closed profiles and highlights them as regions. This enables a dynamic sketch-first experience: once a closed region is detected (e.g. a rectangle or arbitrary closed polygon), the user can select it (solid fill highlight) and issue a Create Face command to turn that region into a sketch face. Multiple regions can be selected and extruded in one go, or separately, giving flexibility for complex sketches with multiple features. Crucially, no drawn geometry is deleted on sketch exit – any unused lines/arcs remain as construction geometry for future editing. This workflow encourages users to “draw 2D, then extrude to 3D”, simplifying the modeling process for beginners.

Construction Geometry & Regions: By default all sketched lines, arcs, etc. do not immediately form solid outlines – they behave as guides until explicitly turned into faces. OneCAD uses subtle visual cues to indicate potential faces: when a closed loop is formed, the interior is shaded lightly (e.g. 10% opacity). Hovering over a region increases opacity, and selecting it confirms the region for face creation. This “construction-first” approach avoids accidental face creation – the user explicitly chooses which loops become solid faces. It also means overlapping or self-intersecting loops are handled gracefully: overlapping loops are detected and only produce distinct regions if they truly enclose an area (overlap without enclosure is ignored or treated as a single region), and blatantly self-intersecting profiles are flagged as invalid (no face created). These rules mirror Shapr3D’s behavior and provide robust feedback to the user. For example, if two loops share some segments or one lies completely inside another, the system will identify separate outer and inner regions (inner loop marked as a hole) to allow creation of a face with a cut-out. Internally, OneCAD builds a planar graph of the sketch geometry and uses an algorithm to extract all cycles (closed loops) efficiently
blog.arcol.io
. Each time the user draws or modifies an edge, the graph is updated and cycles are re-computed. For robust real-time performance, known computational geometry techniques are employed – e.g. we insert intersection nodes if lines cross and break curves into segments for analysis, ensuring we operate on a proper planar straight-line graph
blog.arcol.io
. An optimal cycle-finding algorithm (e.g. Jiang & Bunke’s O(m log m) planar graph face extraction method
blog.arcol.io
) finds all regions, even in complex non-manifold sketches. Despite the advanced algorithm under the hood, the user simply experiences immediate visual feedback: when they close a shape, it highlights – no manual “close loop” action needed. (By contrast, traditional CAD like FreeCAD require leaving sketch edit and running a separate “Validate Sketch” tool to find open loops, which is not real-time
devtalk.freecad.org
 – OneCAD’s integrated approach avoids this friction.)

Multi-Sketch Support: OneCAD’s data model allows multiple sketches in the same plane or on different faces. Sketches can reference each other: for instance, a second sketch can project geometry from the first, or two sketches on parallel planes can be used for lofting. Sketches can also be attached to 3D faces (“sketch on face”) to facilitate direct feature creation on existing bodies. When a sketch is created on a face, OneCAD automatically projects the face’s perimeter edges into the new sketch as reference geometry. These projected edges are marked as construction lines (typically dashed and in a muted color) and are locked in place (the user cannot drag or edit them). They serve as read-only references that the user can then use for constraints (e.g. making a new sketched circle tangent to a projected edge). The system keeps an association to the source face and edge for each projection. If the 3D face later changes (due to model edits), OneCAD will attempt to update the projected edges in the sketch: e.g. if the face’s boundary splits into two edges, the sketch will get both new edges as needed. There is a built-in validation step whenever a feature edit might invalidate sketch projections. If the topology change is straightforward (face modified but essentially in same shape), the projected geometry is updated behind the scenes. If the change is too drastic (e.g. the face was deleted or completely altered so that the old projection has no clear counterpart), OneCAD will warn the user and mark the sketch as needing attention. The user is prompted: “This operation will affect sketches that reference this face… Continue?” and if they proceed, any broken references in the sketch are highlighted in red and must be fixed manually. This ensures that the model doesn’t silently lose associativity – the user is made aware of sketch issues whenever the parent geometry changes. (Notably, this addresses a common pain point in CAD: sketch external references blowing up on topology changes. OneCAD’s approach is to catch it early with warnings, and to use a robust ID mapping for projected edges so minor splits/merges can be auto-resolved when possible.)

Hybrid Parametric & Direct Modeling Behavior

OneCAD is neither a purely direct modeler nor purely history-based – it uses a hybrid modeling paradigm. By default, it encourages direct push-pull edits for speed, but it transparently “upgrades” to a parametric history if constraints demand it. The system logic is: if a sketch is fully constrained, treat it as a parametric feature; if under-constrained, treat it as direct. A flowchart in the specification describes this decision process. In practice, when the user finishes editing a sketch, OneCAD checks its constraint status. A fully constrained sketch (0 degrees of freedom remaining) is considered stable enough for regeneration – meaning any 3D features dependent on it (extrudes, cuts, etc.) can be recalculated if the sketch changes. If such a sketch is edited, OneCAD will by default regenerate the associated features (updating the solid model) rather than treating it as a dumb push-pull edit. Conversely, an under-constrained sketch (still blue geometry, meaning flexible) is treated as a direct edit – the user can move things and the connected solid will deform immediately without re-evaluating a feature history. This prevents chaotic updates from sketches that aren’t fully defined. In effect, under-constrained sketches are in “Direct Mode” (no history replay), while fully-constrained sketches opt into the history tree.

There is also a middle ground: mixed constraint sketches (some geometry locked down, some free). In such cases OneCAD will by default ask the user how to handle it. The first time this occurs, the user is prompted whether to treat such cases as parametric or direct by default (and they can save that preference). Users can also configure globally: always direct, always regenerate if possible, or always ask. These preferences give advanced users control, but the recommended workflow for novices is to let the software decide – which usually means you only get a feature history when you have intentionally fully constrained a sketch (implying you care about precise reproducible geometry). For example, if you sketch a rectangle and fully dimension it (turning green), moving it will prompt a regeneration of any pad/extrude using it (preserving design intent), whereas if the rectangle was only partially dimensioned, you could push-pull its face freely and it would behave like direct modeling (the sketch shape just deforming). This “regenerate only if constrained” rule ensures performance and simplicity: under-defined sketches won’t spawn complex dependencies unexpectedly.

Under the hood, when parametric mode is active, OneCAD maintains a Feature History tree (list of features like Extrude1, Fillet1, etc.) and records each operation’s parameters. Editing a fully constrained sketch will trigger a rebuild of only those features downstream of that sketch. Thanks to the ElementMap (discussed later), faces and edges are tracked so that the right parts of the model update. In direct mode, by contrast, operations are applied immediately to the B-Rep without storing a new feature node (unless the user explicitly converts an operation to a feature). This hybrid design provides flexibility: beginners can ignore the feature tree until needed, and power users can mix direct tweaks with parametric rigor. It’s similar to Shapr3D’s approach where models feel direct but you can opt into history for major edits. OneCAD expands on this by automatically determining mode based on constraints – an innovative twist that avoids mode confusion. Users always have the option to override per document or globally in preferences, but the default strikes a balance between immediacy (direct edits for quick tweaks) and reliability (parametric updates for precise designs).

Constraint Solver Architecture

At the heart of OneCAD’s sketch system is a 2D geometric constraint solver that manages relations between sketch entities. OneCAD uses the open-source PlaneGCS solver (the same solver core used in FreeCAD’s Sketcher) for robust constraint solving. PlaneGCS is a C++ library implementing a variational geometric solver based on nonlinear numerical methods (e.g. Levenberg–Marquardt and Dogleg trust-region algorithms)
github.com
. Each sketch in OneCAD corresponds to an instance of the solver with a set of solver variables representing the geometry (point coordinates, line directions, etc.) and a set of constraint equations. When the user adds a constraint (e.g. a perpendicular constraint between two lines), the solver adds the corresponding equation and attempts to solve the system, finding new positions for the geometry that satisfy all constraints.

Supported Constraints and DOF: OneCAD’s solver supports a comprehensive list of constraint types, covering positional constraints (coincident, midpoint, etc.), geometric alignments (parallel, perpendicular, tangent, concentric, equal radius/length), dimensional constraints (fixed distance, angle, radius, etc.), and symmetry constraints. These mirror the typical offerings of professional CAD. Each unconstrained sketch entity initially has certain degrees of freedom: e.g. a free point has 2 DOF (movable in X and Y), a free line has 4 DOF (its two end points each contribute 2, or equivalently position + orientation + length). When constraints are applied, they remove DOF: e.g. a horizontal constraint on a line removes one DOF (orientation), a coincident constraint between a line endpoint and another point ties those DOF together, etc. OneCAD continuously computes the remaining DOF in the sketch and provides user feedback: unconstrained geometry is shown in blue, fully constrained in green, and over-constrained/conflicting in red or orange. (This color scheme follows Shapr3D’s convention where blue means “still free to move” and green means “locked down”; it effectively gamifies the process – users aim to get everything green for a well-defined sketch.) The software also displays a DOF counter (e.g. “3 DOF remaining”) to guide the user. This DOF analysis is derived from the solver’s Jacobian matrix rank: if there are N variables and M independent constraints, then remaining DOF = N – M (if no redundancy). The solver detects redundant or conflicting constraints by checking the rank deficiency or inconsistency of the equation system
novedge.com
novedge.com
. For instance, adding a distance constraint that mathematically contradicts existing ones will cause the solver to flag a conflict (no solution) – OneCAD will highlight the offending constraints in red immediately and refrain from further solving until the conflict is resolved. If constraints are redundant (e.g. the user accidentally applies two equal length constraints to the same pair of lines), the solver can still find a solution but notes that some equations are dependent; OneCAD will highlight those constraints in amber/orange to indicate they are unnecessary.

Solver Algorithm: Geometric constraint solving is essentially a constraint satisfaction problem solved via nonlinear algebraic methods
en.wikipedia.org
novedge.com
. PlaneGCS (and most modern CAD solvers like D-Cubed’s DCM) combine two major strategies: graph decomposition and numerical iteration
en.wikipedia.org
novedge.com
. First, the constraint problem is represented as a graph where nodes are geometric elements and edges are constraints between them. Using established techniques from academia (e.g. the Decomposition-Recombination (DR) plan by Hoffmann & Joan-Arinyo
novedge.com
), the solver partitions the graph into smaller subsets (clusters) that can be solved in isolation
novedge.com
. For example, if a sketch consists of two separate sub-sketches with no shared geometry, they can be solved independently. Even within one sketch, the graph decomposition might identify solvable chunks (like a triangle of points connected by distances forms a rigid cluster). This reduces the problem size for the numeric solver, improving stability and speed
novedge.com
. Next, the solver tackles each sub-problem using iterative numerical methods. PlaneGCS uses a variant of the Levenberg–Marquardt algorithm (a damped least-squares approach) to solve the nonlinear equations, optionally falling back to Dog-Leg or BFGS methods in difficult cases
github.com
. It constructs a Jacobian matrix of partial derivatives and iteratively adjusts the variables to drive constraint errors toward zero
novedge.com
novedge.com
. If the system is well-constrained (DOF = 0), a solution can be found (given a reasonable initial guess), and if under-constrained, the solver finds one of infinitely many solutions (so the remaining freedom corresponds to the DOF the user can still drag). The solver also handles slightly over-constrained cases by finding a least-squares fit (but in CAD we typically alert the user instead of accepting an approximate solution).

OneCAD’s integration of PlaneGCS configures it to update in real-time as constraints are added or geometry is dragged. The solver is fast for typical sketch sizes (tens of elements) – solving usually in a few milliseconds – which enables interactive feedback. For very complex sketches, OneCAD may briefly pause solving during rapid dragging to maintain performance, but this is rare in beginner workflows. The PlaneGCS solver is thread-safe and can even utilize multithreading for parts of the linear solution step
spatial.com
, although in OneCAD’s current version we solve on the GUI thread to simplify synchronization (sketch solving is quick enough). The advantage of using PlaneGCS is that it’s a proven engine: it can handle all standard constraint cases, detect degenerate conditions, and it’s open source, allowing OneCAD to extend it if needed. Notably, the solver can identify when a sketch is under-constrained but stiff (e.g. a rectangle with three sides dimensioned – technically one DOF left, but the shape can only move rigidly). The rigidity analysis from graph decomposition and Jacobian rank helps OneCAD provide intuitive manipulation: unconstrained points are shown with drag handles, while fully constrained or fixed points won’t move. If a user tries to drag a green (fully defined) shape, OneCAD will either move the entire sketch (if there are 3 global DOF meaning just free rigid-body motion) or show it as locked in place. This is possible because the solver distinguishes global degrees of freedom (like whole-sketch translation) from internal DOF
novedge.com
.

Mapping Sketch to Solver Entities: Internally, OneCAD maintains a mapping between its sketch geometry data structures and the solver’s variables. For example, when the user creates a line in the sketch, OneCAD creates two solver variables for the endpoints (x1,y1,x2,y2) or a similar minimal representation, and a solver Line entity that links those points. Constraints in OneCAD (represented as objects like ConstraintHorizontal or ConstraintCoincident) correspond to specific solver constraint equations added to PlaneGCS (e.g. horizontal means set line’s angle = 0). When a sketch is solved, OneCAD reads back the updated variable values and applies them to the actual geometry in the scene (moving the points accordingly). This happens rapidly and transparently during dragging: as the user drags a point, OneCAD continuously feeds the new position as a target and asks the solver to re-solve for the rest of the geometry, thus achieving real-time constraint solving. The result is a smooth interactive experience – as users drag a point, other connected geometry slides or rotates appropriately to satisfy all constraints, giving immediate visual feedback
novedge.com
. This direct manipulation is essential to making constraints feel intuitive rather than frustrating. OneCAD’s solver interface is designed so that small movements solve quickly; if a drag is too large and solver convergence slows, the UI may momentarily simplify (e.g. suspend solving until the mouse is released, similar to FreeCAD’s advice to do big moves in steps
forum.freecad.org
). In most cases, though, the user can freely tug on under-defined geometry and see it behave obeying the existing constraints (like dragging one corner of a rectangle will move the whole rectangle if it’s fully constrained except free placement).

Constraint Suggestion and Inference: OneCAD assists the user by suggesting constraints during sketching. As in Shapr3D, if you draw a line almost horizontal, a ghosted “Horizontal” constraint icon appears near it. The user can accept it (by clicking or just by finishing the line near perfectly horizontal) and OneCAD will automatically apply a horizontal constraint. Similar suggestions appear for vertical alignment, perpendicular intersections, coincident endpoints, etc., using a snapping system. This auto-snap inference greatly speeds up sketching – you often don’t need to manually invoke the constraint tool at all for common relations, they’re implied by how you draw. The auto-constraints are only applied if the user confirms (explicit or implicit threshold), so the user stays in control (we also provide a global toggle “Auto-constrain while drawing” which is ON by default in OneCAD’s preferences, since novices benefit from it). If auto-constraint is toggled off, the user can still manually add constraints after drawing. OneCAD supports both noun-verb and verb-noun workflows for manual constraints: e.g. you can select two lines (nouns) then click “Parallel” (verb), or activate the Parallel constraint tool first and then pick the lines. The UI, however, is optimized for noun-verb via context – when geometry is selected, a contextual palette shows applicable constraints (on the sidebar or as floating icons), so with one tap you can apply one. This context-driven UI means constraints are only a click away but also not cluttering the interface when you don’t need them (when nothing is selected, constraint tools are hidden to avoid overwhelming the user). All constraints added are listed in a panel (with names like “Coincident1, Horizontal2”), but by default OneCAD shows very minimal on-canvas annotation to avoid clutter. We only display small icons next to geometry when necessary – e.g. a padlock icon if a point is fixed in place, or a perpendicular ⟂ symbol when two lines are perpendicular. And even these icons fade or declutter when you zoom out or deselect, so the sketch isn’t littered with symbols. This design follows Shapr3D’s principle of minimal icon clutter, using color and subtle cues rather than verbose labels. Power users can enable a “Show all constraints” mode which displays all icons, and there’s always the textual list if needed for clarity, but the default is clean.

Sketch User Experience Features

Dimensions and Editing: OneCAD integrates dimensions seamlessly into the sketching process. When you create a distance or angle constraint, the dimension appears as a text label on the canvas, attached to the relevant geometry. The user can click the label to edit the value (a small input box appears, supporting numeric entry and units). This allows the “rough then refine” workflow: you roughly sketch a shape by eye or dragging, then type in exact measurements for precision. For example, draw a line, then click its length label and type “50 mm” to set it exactly – OneCAD handles unit conversion (in v1 metric is default, but you can type “2 in” and it will convert to 50.8 mm, as unit handling is built-in). During dragging, OneCAD may also show dynamic dimensions – e.g. as you drag a line, a temporary length indicator follows the cursor updating in real time. If you stop and click that label, you can enter an exact value, which finalizes by adding a dimension constraint of that value. This makes precision input feel a natural part of drawing, not a separate mode. All dimension labels can be double-clicked later to change the value, causing the solver to update the sketch immediately to satisfy the new number. Color cues tie into this: a changed dimension that over-constrains the sketch will highlight in red, alerting you to the issue. OneCAD supports expressions in dimension fields (e.g. entering = 2 * Diameter1 to link values) as a future feature (v1 might only support simple values, but the architecture is ready for parametric equations, since PlaneGCS can accept driving dimensions and we can re-solve equations).

Visibility and Clutter Management: By default, when you exit a sketch (finish editing), OneCAD hides the construction geometry and constraints of that sketch in the 3D view. The resulting solid faces are shown, but the underlying sketch lines are not rendered (this is configurable – you can show sketch geometry in the scene if desired, but for a beginner-friendly default, a consumed sketch is hidden to avoid confusion). Within sketch edit mode, OneCAD keeps the visual style clean: the grid is visible (if enabled) and constraints are only indicated through minimal graphics. Constraint icons that are shown (like locks or perpendicular markers) are drawn smaller and semi-transparent to avoid obscuring the drawing. The user can hover or click on a constraint icon to see what it is, and selecting it will also highlight the related geometry (and vice versa). If things do get busy, the user has the option to toggle off the display of all constraint icons – leaving only color cues (blue/green) – and then toggle it on when needed to inspect. We took inspiration from Shapr3D’s approach: Shapr3D places small informative icons directly on the canvas (instead of in a separate list) to give ambient info without requiring reading a log. OneCAD does the same, but ensures these icons never overwhelm the view: only critical ones like *fix/*lock or error symbols persist visibly. The constraints sidebar on the right in sketch mode lists all constraints in text form, which is useful for complex sketches – but by default, a beginner might not need to open that panel often, since most constraint interactions are direct on canvas or via context toolbars.

Sketch Inference & Snapping: While drawing, OneCAD provides inferencing lines and snap points – for example, as you move your cursor near horizontal alignment with another point, a guideline appears and a Horizontal inference is shown (which if you click will place a horizontal constraint). Similarly, you’ll see midpoint snap markers, perpendicular guidelines, etc. This guidance greatly reduces the effort to create well-constrained sketches. It is essentially giving the user a chance to add constraints without explicitly activating a constraint tool – a hallmark of modern CAD UX. The user still retains manual control: if you don’t want that horizontal constraint, you can ignore the suggestion (e.g. draw the line at a slightly off angle or turn off auto-constraint toggle temporarily by holding a modifier key). Our research and Shapr3D’s success indicate that conservative auto-inference is beneficial – suggest common constraints but avoid overly aggressive snapping that frustrates the user. Thus OneCAD’s inference engine is tuned to only snap when the cursor is very close to the intended alignment or point, to prevent “jumping” behavior. This can be adjusted in preferences (snap sensitivity).

Conflict and Error Feedback: When the solver encounters a conflict (unsolvable constraint set), OneCAD immediately provides visual feedback. For example, say a user accidentally constrains a square’s diagonal distances inconsistently. The affected constraints will be highlighted in red, and a “Constraints Conflict” warning will appear in the sketch panel. OneCAD goes a step further by offering a debugging aid: the UI can isolate which constraints are in conflict (e.g. flashing them or listing their names in an error tooltip). The user can then decide to delete or disable one of them. To assist novices, OneCAD will include a “Sketch Solver Diagnostic” tool (a visual debugger) that can be invoked when a sketch has problems. This tool will analyze the constraint system and suggest resolutions. For instance, if the sketch is over-constrained, it can identify a set of redundant constraints and propose “Remove constraint X or Y to fix over-constraint” – similar to SolidWorks’ SketchXpert functionality which finds sets of constraints to remove to resolve conflicts
blogs.solidworks.com
. OneCAD’s implementation will list possible solutions (which constraints to relax) for the user to choose from, rather than automatically deleting anything. This interactive fix guide, along with clear highlighting of problem constraints, will significantly improve the UX compared to the cryptic error messages of older CAD software. In v1, the conflict feedback might be more basic (red highlights and a message), but the architecture is laid for a full debugger interface. Importantly, OneCAD tries to avoid getting into unsolvable states in the first place by preventing certain actions: for example, if the user already fixed two points coincident, we might disable the option to apply a distance between them (since that would be redundant/conflicting). Where possible, the UI will gray out or warn before adding a obviously redundant constraint – though it cannot catch all cases, it will catch many. In summary, error handling in sketches is user-friendly: constraints causing trouble are clearly marked, an explanation is given, and guidance (or at least the ability to quickly select and delete the offending constraint) is provided
reddit.com
wiki.freecad.org
. This addresses a known UX limitation in Shapr3D and others, where users complained that when something turned red, they didn’t know why. OneCAD will make it clear and easy to fix.

Performance Considerations

Real-time interactivity is a key goal of OneCAD’s sketcher. The system is designed to handle typical hobbyist sketches (dozens of elements, dozens of constraints) without lag on modest hardware. The solver (PlaneGCS) is lightweight and written in C++ for speed, and our tests show it can solve ~100 constraints in a fraction of a second on modern CPUs. The UI is optimized to only solve when needed – e.g. during a drag, we solve at a throttle that balances smooth motion with CPU usage (perhaps every few frames). If a sketch somehow becomes very large (hundreds of constraints), the solve step might be noticeable; OneCAD will detect this and could degrade gracefully (e.g. not solve on every mouse move, only on drop). However, v1 scope expects sketches to remain reasonably sized given the target user base (makers doing relatively simple designs). On the loop detection side, the face-finding algorithm is efficient (O(n log n)), and with n (edges) typically being in the tens, this is negligible. Even for heavier use (like someone drawing floorplan-like networks), our adoption of an optimal algorithm ensures we can handle it. Arcol’s CTO demonstrated a robust method to extract faces from arbitrary line networks in real-time
blog.arcol.io
, and OneCAD’s implementation is similar but with slightly relaxed scope (we may not support open-network face fills like floorplans in v1, focusing on closed profiles). Still, the algorithm is more than capable of the intended use cases. We also leverage spatial indexing for snap and inference queries, ensuring that finding nearby points or alignments is instant even as geometry count grows.

From a rendering perspective, sketch entities are simple (2D lines and curves), so drawing them is cheap. We use GPU acceleration via Qt’s rendering, and only a few hundred vertices are involved in most sketches. Constraint icons are small UI overlays. Therefore, the UI remains responsive. The only potentially heavy operation is updating references when 3D geometry changes (ElementMap updates, see below), but those typically happen after a feature edit, not in the middle of interactive sketching, so a 0.1s update is acceptable after, say, an extrude.

Memory footprint of sketches is minimal – a few bytes per solver variable and per constraint. Even with history on, storing a sketch feature with its constraint data is tiny compared to the B-Rep of the resulting solid. So users can freely use multiple sketches without bloating the file.

Persistence and Topological Naming (ElementMap)

OneCAD implements a persistent ID mapping system, called ElementMap, to tackle the notorious topological naming problem in CAD. The topological naming issue refers to the tendency of parametric CAD models to “lose” references when geometry changes – e.g. face #5 might become face #7 after a cut, invalidating any external references to “face #5”
orionrobots.co.uk
. OneCAD’s ElementMap assigns stable identifiers to geometric entities (faces, edges, vertices) of bodies and tracks them through modeling operations, so that features like sketches on faces or constraints to edges remain attached even if the model is modified. In essence, it provides a many-to-many mapping between ElementId (a stable name) and actual OCCT shapes, updating after each boolean or transformation.

Stable ID Generation: Rather than using transient indexing or creation order, ElementMap generates deterministic IDs based on the operation and geometry characteristics. For example, when an Extrude is created, it might produce several faces. Instead of labeling them sequentially (face-1, face-2, etc. which can change on reload), OneCAD computes a signature for each face – e.g. using the face’s surface type and position (centroid or normal) – and incorporates the feature’s unique ID. So you might get IDs like extrude1/face-<hash>. This ensures that if you recompute the model, the same face will get the same ID every time, because the hash is derived from geometric properties that persist. Contrast this with a naive counter approach (face1, face2, …) which can shift unpredictably. The ElementMap in OneCAD v1 uses a combination of each feature’s unique tag (each feature operation is given a GUID or stable index) and a geometric sorting (like sorting all result faces by some stable criteria) to generate IDs. This way, even if upstream operations change, as long as a given face still exists in the feature result, it will be recognized. For instance, Extrude1’s side faces might be identified by being vertical and rectangular; if Extrude1’s sketch changes dimension, those side faces are still there and get the same IDs again because their descriptor (vertical planar face spanning from profile to end) remains consistent.

Tracking OCCT History: When OneCAD performs a modeling operation (like a Boolean cut or a fillet), it uses OpenCASCADE’s BRepAlgoAPI tools to get a history of shape modifications. OCCT provides methods like Generated() and Modified() which map input shapes to output shapes. OneCAD’s ElementMap leverages these to update IDs. For example, if a boolean cut modifies face F1 of a solid into two new faces (F1a and F1b), OCCT’s Modified(F1) will return the list [F1a, F1b]. ElementMap will detect this split event and assign new IDs accordingly. In the current implementation (before fixes), it would pick one as “best match” and keep F1’s ID on it, and the other face would unfortunately lose identity. Our plan (and ongoing fix) is to assign sibling IDs in such cases. So if cube/face-2 splits into two, one keeps cube/face-2 and the other might get cube/face-2#split-1 (an appended suffix). Both carry a reference to the original face-2 as parent in the map. This way, any sketch or feature that was referencing the original face can be deterministically reassigned to one or both new faces as appropriate, or at least we can warn the user and let them choose. Similarly, if two faces merge into one (for instance, a fillet might consume two faces into a single rolled face), ElementMap would mark one of the original IDs as merged and have the new face carry one of the original IDs (preferring the dominant one) while the other ID is retired. In either scenario, the key is that ElementMap knows what happened and can therefore update or flag references. Nothing is left hanging referring to a non-existent entity without the software realizing. This addresses classic parametric failures – e.g., in FreeCAD without robust naming, a sketch on “Face6” can suddenly start floating because Face6 became Face7; in OneCAD, the sketch on extrude1/face-42 will either find that exact face in the updated model or ElementMap will tell us that face was split/merged and map it accordingly or report it missing. The outcome is a much more stable parametric model.

Design vs. OCAF and FreeCAD Approaches: We evaluated existing solutions like OCCT’s own OCAF TNaming system and FreeCAD’s RealThunder algorithm. OCAF’s TNaming gives a general mechanism to track shapes through an internal delta tree – but it requires using the entire OCAF document framework (big learning curve, lots of overhead) and we opted not to impose that on OneCAD. Instead, we implement a lightweight custom solution (ElementMap) that is integrated with our Document but doesn’t require the heavy OCAF data structures. FreeCAD’s RealThunder approach (expected in FreeCAD 1.0) is quite comprehensive – it uses string-based names encoding the entire history of an element (like Pad001.Face1.BaseFeature:Edge5 etc.) and even encodes geometrical adjacency in the names. That approach is very robust but results in long identifiers and was built to solve FreeCAD’s specific issues with no compromise on complexity. Our ElementMap takes inspiration from it (for example, using history-based naming and keeping a reverse map from shape to name), but we aim for a simpler scheme given our target use cases. We ensure determinism and basic split handling, which should cover the vast majority of beginner projects (which are unlikely to have extremely complex topological changes). Even so, in internal testing our initial ElementMap review identified critical fixes needed (which we’ve implemented): making IDs deterministic (no global counter), handling splits by assigning siblings, adding serialization, and enriching the descriptors used to match shapes. With these fixes, OneCAD’s naming system is substantially more reliable than the “naive” approach. It’s estimated to be ~40% of the way to the sophistication of FreeCAD’s solution, but that is sufficient for v1 since our scope is narrower. Notably, we track faces through Boolean operations and parametric updates well, but we do not yet track every edge and vertex with a persistent ID (FreeCAD does some edge naming using adjacent faces in the name). In OneCAD v1, edges inherit stable IDs indirectly (e.g. an edge is often the intersection of two faces, so if those faces are stable, we find the edge via those), and sketches on faces or edges are mostly resolved via face IDs. This covers most cases (e.g. a sketch projected edge is tied to a face’s perimeter index; if face splits, we handle it as above).

Serialization: ElementMap is fully integrated into OneCAD’s .onecad file format. When saving, the ElementMap writes out all current entries: each ElementId and the necessary data to recover it (likely a descriptor hash and references to original feature). For example, an entry might be stored as { id: "extrude1/face-2", feature: "extrude1", descriptor: (surface=plane, normal=(0,1,0), area=123) }. Upon loading a file, OneCAD replays the feature history to regenerate the shapes, but it uses the saved ElementMap to re-link any external references. If everything matches perfectly, each regenerated shape will be assigned the same ID as before (because our ID scheme is deterministic); the ElementMap file data serves as a safety net and a check. If there is any discrepancy, OneCAD can flag it – for instance, if a face that used to exist is no longer present after recompute (perhaps due to a modeling change or version difference), the ElementMap will notice that an expected ID cannot be found and will notify the user that a reference is broken. In general, though, because we use stable IDs, a model reloaded in the same version of OneCAD should map 1:1 and the user won’t notice anything special – their sketches and constraints will still be hooked to the right geometry. The benefit of serialization is also that it future-proofs against changes in the kernel: if we upgrade OCCT or alter modeling algorithms, as long as the same geometry can be recognized, the IDs persist. And if not, we have the mechanism to warn the user rather than silently flipping references.

To give a concrete example, consider a user attaches Sketch2 to the top face of Extrude1 in version 1 of the model. ElementMap gives that top face an ID like “extrude1/face-top”. Sketch2 stores that reference (via ElementId). The user saves and later reloads. On reload, Extrude1 is recomputed; ElementMap looks at Extrude1’s result faces, computes their stable IDs (centroid, orientation, etc.), and comes up with the same “extrude1/face-top” for the top face. It then sees Sketch2 wants “extrude1/face-top” – finds it – and links Sketch2’s plane to that face. The user never has to reassign anything. If the user then modifies the extrusion (say changes the profile so it now has two top faces due to a pocket feature making a hole), our update logic will detect the original top face split into an outer ring and an inner face. We might keep “extrude1/face-top” on the outer ring and give the inner face “extrude1/face-top#split-1”. Now Sketch2 was referencing the top face – which one should it go to? In this scenario OneCAD would likely keep it on the original outer face (since that was the “boundary” face) and warn the user that an internal face was created that Sketch2 might want to reference if it were intended to. If Sketch2’s reference was instead to a specific internal region, then after the change we might not be able to auto-resolve and thus flag the sketch as needing reattachment by the user. These are edge cases, but the system is built to handle them as gracefully as possible.

Overall, OneCAD’s approach to persistent naming is pragmatic and robust: use the available OCCT history data, augment with geometric hashing for determinism, and maintain a bidirectional map of IDs↔Shapes. This ensures that parametric features only regenerate the necessary portions of the model and that dependent sketches or constraints remain intact through edits. Users of OneCAD will enjoy a level of stability in parametric behavior that is typically found only in more mature CAD systems. For completeness, we include a brief comparison:

Without ElementMap: Changing an earlier feature could rename faces arbitrarily (as in many older CAD systems), causing sketch attachments and constraints to mis-target or fail
orionrobots.co.uk
orionrobots.co.uk
.

With ElementMap: Changing an earlier feature updates the internal map but keeps IDs consistent, so everything stays connected, or at worst the user is notified exactly which references couldn’t be resolved and why.

This reliability is critical for maintaining user trust in the modeling process – a beginner won’t be mystified by their fillet suddenly disappearing or a hole jumping faces, because OneCAD either preserves the link or clearly flags the issue for correction.

Architecture and Implementation Blueprint

The OneCAD sketching system is divided into modular components for data, solving, and UI, ensuring a clear separation of concerns (as depicted in our architecture diagram). Below is a high-level class and module structure:

flowchart TB
    subgraph SketchEngine ["SketchEngine (Sketch Module)"]
      Sketch[Sketch Entity Data]
      Constraints[Constraint List]
      LoopDetect[LoopDetector]
      SolverInterface[ConstraintSolver Interface]
      ElementMapMgr[ElementMap Manager]
    end
    subgraph SolverCore ["PlaneGCS Solver Core"]
      GCSSystem[[GCS System]]
    end
    subgraph UILayer ["UI Layer"]
      SketchUI[Sketch Editor UI]
      Inspector[Constraint Inspector Panel]
    end
    subgraph Modeler["3D Modeler"]
      FeatureHistory[Feature History Tree]
      OCCTKernel[OCCT BRep Kernel]
    end

    Sketch --> SolverInterface
    Constraints --> SolverInterface
    SolverInterface --> GCSSystem
    LoopDetect --> Sketch
    Sketch --> LoopDetect
    Sketch --> ElementMapMgr
    FeatureHistory --> ElementMapMgr
    ElementMapMgr --> FeatureHistory
    FeatureHistory --> OCCTKernel
    ElementMapMgr --> OCCTKernel

    SketchUI --> SketchEngine
    Inspector --> SketchEngine
    SketchUI --> Inspector


SketchEngine & Data Model: The central class is Sketch (within SketchEngine module), which contains collections of geometry elements (points, lines, arcs) and a list of Constraint objects. Each geometry element has a unique ID within the sketch. The Sketch class owns a LoopDetector sub-component that maintains the connectivity graph of the sketch and finds closed loops whenever the geometry changes (using the algorithms discussed). It marks regions and communicates with the UI for highlighting. The Sketch also has a reference to the ConstraintSolver Interface, which acts as a bridge to the PlaneGCS GCSSystem. The solver interface is responsible for creating solver variables corresponding to the sketch’s geometry and adding/removing constraints in the solver whenever constraints are added, removed, or changed in OneCAD. Essentially, when you open a sketch, the solver interface builds a PlaneGCS model of that sketch: e.g. creates GCS points for each OneCAD point, GCS line for each OneCAD line (tying to two GCS points), etc., then adds GCS constraints for each OneCAD constraint. The solver interface then invokes GCSSystem::Solve() whenever needed. It also handles incremental updates: e.g. if you drag a point, it will pin that point’s variable and solve for the rest, or if you move it in small increments it will continuously update.

Solver Core: The SolverCore (PlaneGCS library) is external but linked. It provides classes like GCS::Point, GCS::Line, GCS::ConstraintEquation etc. We don’t modify the core; we use it through the interface. This core does the heavy math – solving the nonlinear equations. It supports multiple solver algorithms and even has diagnostic outputs (which we can use for advanced features like telling the user which constraints are redundant by querying the solver’s rank analysis).

ElementMap Manager: Outside the sketch, at the application level, is the ElementMap system. It is integrated with the modeling operations. Every time a feature (Extrude, Cut, Fillet, etc.) is executed, OneCAD’s FeatureHistory system calls ElementMap.update(oldShape, newShape, opType) to update IDs. For example, update() takes the OCCT history from an operation and updates its internal maps accordingly (using the logic described for splits/merges). The ElementMap provides APIs for querying: e.g. given a TopoDS_Shape (from OCCT) it can return the stable ElementId if known, or given an ElementId it returns the current TopoDS_Shape in the model. The ElementMapMgr interacts with both the FeatureHistory (to know which operation’s output we’re dealing with and assign parent IDs) and the OCCT Kernel (to fetch history info via BRepAlgoAPI). It also interacts with SketchEngine: when a sketch on face is attached, we store the ElementId of that face in the sketch. Later, if that face ID is updated by ElementMap (say face got split), the sketch queries ElementMap to find the new corresponding face shapes. Thus, Sketch will ask ElementMap for “give me the shape for my reference face ID” whenever it needs to reattach. The loose coupling via IDs means the sketch doesn’t need to know about the model details – it just holds an ID, and ElementMap resolves it.

UI Layer: The UI consists of a Sketch Editor (which includes the 2D canvas overlay and in-canvas controls) and panels like a Constraint Inspector or a small toolbar of constraint tools. The SketchUI communicates with SketchEngine – for example, when the user presses the horizontal constraint button and selects two lines, the UI calls something like Sketch.addConstraint(HorizontalConstraint, line1, line2). The SketchEngine creates the constraint, adds it to its list, and through SolverInterface, adds it to the solver and re-solves. If the solver reports success, the SketchUI then updates the view (maybe flash a confirmation). If solver reports conflict, SketchUI is notified to, say, blink the new constraint in red and show an error message. The UI also queries SketchEngine for things like “what’s the DOF count?” so it can display it – SketchEngine gets that from SolverInterface’s analysis of the GCS system (e.g. number of free variables). The Inspector panel shows all constraints; it listens to selection events (if user selects a constraint in the list, highlight in canvas, and vice versa). The UI also handles the user toggling auto-constraints: if auto-constraint is ON, SketchUI will call into SketchEngine at drawing time to apply those inferences (e.g. as you draw a line, SketchUI calls something like SketchEngine.suggestConstraint(Horizontal, lineTemp) and if the user confirms, it actually calls addConstraint). This separation ensures the back-end logic (SketchEngine, solver) is independent of how the user triggers actions – useful for future scriptability (e.g. macros can add constraints by calling the same API).

Workflow Example (Drag & Solve): When the user drags a point in the sketch, the event goes to SketchUI, which in turn calls SketchEngine.movePoint(pointId, newX, newY) continuously as the mouse moves. Inside that, Sketch updates the point’s coordinates (to the tentative new position) and then calls SolverInterface.solve() to recompute the other coordinates given that move. The solver might treat that point as temporarily fixed (or simply take the last solution and use the new position as a starting point) and solve the equations. The result comes back, SketchEngine updates the other points/lines positions accordingly, and SketchUI redraws the sketch at the new positions. This loop happens maybe 30 times per second, giving smooth motion. If at any time the solver cannot solve (maybe the drag was trying to violate a constraint), SketchEngine will either constrain the drag (so it stops at the solvable limit) or cancel the move and highlight the issue. Typically, the solver will just handle it and you’ll feel a spring-like resistance if you drag into an impossible configuration, since the solver won’t stray far from a solvable state.

File Save/Load: During save, the Document asks ElementMap for its data and writes it (along with the list of features and their parameters, and the sketches with their constraints). A sketch in the file thus contains: its geometry (with numeric values), its constraints (with references to geometry by IDs within the sketch), and any external references (by global ElementId). When loading, the model is rebuilt feature by feature. After feature geometry is created, ElementMap is populated such that by the time we get to a sketch that references extrude1/face-2, that ID is already known in the map (because Extrude1 feature when replayed updated the ElementMap). Then the Sketch is loaded: its internal geometry is created, its constraints applied, and for any external references the SketchEngine queries ElementMap to get the actual shape (for attaching) or the actual 3D coordinate (for projected geometry endpoints). The solver then solves to ensure the sketch is properly positioned (e.g. if a projected line was attached to a moving edge, we might solve constraints that fix it in space accordingly).

In summary, the implementation cleanly separates data/model (Sketch, Constraints, ElementMap), solver logic (PlaneGCS via SolverInterface), and UI (sketch editor, inference UI, inspector). This modularity makes it easier to maintain and extend. For example, replacing PlaneGCS with another solver (like upgrading to D-Cubed DCM if ever desired) would mostly involve writing a new SolverInterface adapter, without touching Sketch or UI logic. Similarly, the ElementMap is a self-contained module that could evolve (e.g. to track edges in future) without affecting the sketch or solver – it just provides queries for stable references.

Debugging and UX Enhancements

As a final note, the system includes a Visual Debugger for Constraints, aimed at education and troubleshooting. This will likely be a mode in the sketch UI where the user can click “Diagnose Sketch.” When active, the solver runs a diagnostic pass: it identifies any conflicting constraints, redundant constraints, or degrees of freedom. OneCAD then visually annotates the sketch: e.g. highlighting conflicting constraints in red and drawing an arrow or marker to indicate the location of the conflict. If two constraints conflict, it might draw a small lightning bolt icon between them or list “Constraint 4 conflicts with Constraint 7” in a popup. For redundant ones (say you applied both vertical and parallel to Y-axis on the same line – one is redundant), it could mark one in orange and note “redundant (already vertical by other constraint).” We’ll also leverage solver analytics to suggest which constraints to remove. This is akin to SolidWorks’ SketchXpert
blogs.solidworks.com
: OneCAD can automatically disable one constraint at a time and see if the system solvable, thereby finding a minimal set to remove. It can then present the user with options: “Remove Horizontal1 or remove Vertical3 to resolve conflict”. The user can choose, and the sketch will update accordingly. Another aspect of debugging is DOF visualization: in the diagnostic mode, OneCAD can highlight which points or lines are free to move (perhaps with small arrows indicating possible motion). Shapr3D does something like showing unconstrained points in a different color, but we can be more explicit: e.g. if a rectangle can still move in X, we draw a double arrow symbol showing that translational freedom. This helps users understand what’s under-constrained. Given the time constraints, not all these features may be in v1, but the architecture (particularly the solver’s ability to compute nullspace of Jacobian for DOF and to detect rank deficiency for redundancy
novedge.com
) supports it. The UI will evolve to expose these capabilities in intuitive ways (e.g. a “?” help mode that when toggled, if you click a blue line it will hint “this line can still rotate” or “move this point to fix degrees of freedom”).

Finally, beyond sketches, OneCAD’s hybrid nature means debugging the overall model history is also important. If a regeneration fails (say a loft or boolean can’t solve), OneCAD will not simply give a generic error – it will attempt to highlight the geometry causing the issue. For example, if a boolean union fails because of non-intersecting bodies, OneCAD will highlight those bodies in the viewport for the user. This concept extends the visual debugger idea to 3D operations. We mention it to illustrate OneCAD’s general philosophy: make errors visible and fixable, not cryptic. This is something even Shapr3D could improve (users note that Shapr’s boolean failure just says “cannot create result” without showing where). OneCAD’s planned improvement is to, for instance, paint the overlapping area in red if a boolean subtract fails due to no intersection – so the user immediately sees the issue.

In conclusion, the OneCAD Sketching and Constraints system is built to be approachable yet powerful. It draws on proven solutions (PlaneGCS for solving, well-known algorithms for loop detection, established best practices for UI from Shapr3D) and enhances them with OneCAD’s unique hybrid modeling workflow and robust naming/persistence layer. The result is a sketch environment where a beginner can draw and experiment freely – the software gently constrains and guides them (with snaps, color cues, minimal UI clutter) – and as their design grows, the under-the-hood rigor (constraints solver, parametric regen, stable IDs) ensures the model remains consistent and editable. This detailed design and implementation plan gives us a clear blueprint to proceed with coding the system in C++20 with Qt6, integrating tightly with OCCT for geometry and using PlaneGCS for constraints, while providing a modern, intuitive UX that lowers the barrier to CAD for our target maker audience.

Bibliography

Hoffmann, C. & Joan-Arinyo, R. (2005). “A Brief on Constraint Solving in Computer-Aided Design.” Purdue University Technical Report. – Discusses graph-based decomposition and algebraic solving in CAD constraint systems, informing OneCAD’s solver strategy
novedge.com
novedge.com
.

Jiang, X. Y. & Bunke, H. (1993). “An optimal algorithm for extracting the regions of a plane graph.” Pattern Recognition Letters, 14(11), 791-800. DOI: 10.1016/0167-8655(93)90104-L – Provides the theoretical basis for OneCAD’s loop detection engine, ensuring robust face identification in sketches
blog.arcol.io
.

PlaneGCS (FreeCAD Sketcher Solver) – FreeCAD source code repository. (2016). Available at: https://github.com/FreeCAD/FreeCAD/tree/master/src/Mod/Sketcher/App/planegcs. – The 2D constraint solver library integrated into OneCAD for solving geometric constraints
github.com
github.com
.

Shapr3D Support – “Sketching Basics: Constraints and Dimensions.” Shapr3D Docs. – Describes the color-coding of sketch constraints (blue vs green) and the minimalistic constraint UI that inspired OneCAD’s design.

SolidWorks SketchXpert – SOLIDWORKS Online Help. Dassault Systèmes. – Details the SketchXpert conflict resolution tool, which influenced OneCAD’s constraint debugger for offering removal suggestions when conflicts arise
blogs.solidworks.com
.

FreeCAD Wiki – Topological Naming Problem. (2023). FreeCAD Documentation. – Explains the topological naming issue and references RealThunder’s algorithm adopted in FreeCAD, which guided OneCAD’s ElementMap development for stable references
orionrobots.co.uk
.

Spatial Corp. – Constraint Design Solver (CDS). (2021). Spatial.com Product Page. – Industry documentation on a commercial geometric constraint solver, confirming the importance of under/overconstraint diagnostics and real-time solving, capabilities mirrored in OneCAD
spatial.com
spatial.com
.

Arcol – Extracting Faces from Graphs. (2022). Blog post by P. Rideout (Arcol CTO). – Describes a practical implementation of face extraction in planar sketches, including handling of intersections and holes, which inspired OneCAD’s approach to region detection
blog.arcol.io
blog.arcol.io
.

FreeCAD Forum – PlaneGCS integration in Salome SHAPER. (2017). – A discussion confirming successful reuse of FreeCAD’s PlaneGCS in another CAD system, indicating its reliability and guiding OneCAD’s integration approach
devtalk.freecad.org
.

Gemini CAD Research – Shapr3D MacOS UX Review. (2025). – Provided insight into Shapr3D’s UX patterns such as adaptive menus and visual feedback, many of which are incorporated into OneCAD’s sketch UI design.